/* -------------------------------------------------------------------------- *
 * Ancienne méthode utilisée pour créer les courbes de couple et de puissance *
 * Cette méthode se basait sur les rpm moteur et non ceux du rouleau ...      *
 * -------------------------------------------------------------------------- */
void MainWindow::createCoupleAndPowerCurves(
        QString const& megasquirtCSVFilename)
{
    QCSVParser MSFile(megasquirtCSVFilename, ';', QString::KeepEmptyParts);
    QCSVColumn times = MSFile["times"];
    QCSVColumn rpm   = MSFile["rpm"];

    QVector<QPointF> couplePoints;
    QVector<QPointF> powerPoints;

    double w1, w2, wIntermediate;
    double accAngulaire;
    double couple, puissance;
    const double PI = 3.141592653589793;
    const double Jdelta = 0.22; // FIXME : demander à l'utilisateur de rentrer la valeur

    int lastDataIndice(0); // Used for futur data filtering.

    w2 = (PI * rpm.at(0).toDouble()) / 30;

    for (int i(1); i < times.count(); ++i)
    {
        w1 = w2;

    /* ---------------------------------------------------------------------- *
     *                           ωx = (π * Nx) / 30                           *
     * ---------------------------------------------------------------------- *
     * ωx = Vitesse angulaire à l'instant x (rad/s)                           *
     * Π  = Pi, constante qui vaut 3.141592653589793...                       *
     * Nx = tours par minute à l'instant x == RPM (tours/minute)              *
     * ---------------------------------------------------------------------- */

        w2 = (PI * rpm.at(i).toDouble()) / 30;

        qDebug() << "w1 = " << w1;
        qDebug() << "w2 = " << w2;

    /* ---------------------------------------------------------------------- *
     *                        α = (ω2 - ω1) / (t2 - t1)                       *
     * ---------------------------------------------------------------------- *
     * α  = Accélération angulaire (rad/s²)                                   *
     * ωx = Vitesse angulaire à l'instant x (rad/s)                           *
     * tx = temps x (s)                                                       *
     * ---------------------------------------------------------------------- */

        accAngulaire =                    (w2 - w1)
                                              /
     ((times.at(i).toDouble() - times.at(lastDataIndice).toDouble()) / 1000000);
        // times values are microseconds

        qDebug() << "t2 = " << times.at(i).toDouble() << " microsecondes";
        qDebug() << "t1 = " << times.at(lastDataIndice).toDouble() << " microsecondes";
        qDebug() << "Δt (t2 - t1) = " << ((times.at(i).toDouble() - times.at(lastDataIndice).toDouble()) / 1000000);
        qDebug() << "α = " << accAngulaire;

    /* ---------------------------------------------------------------------- *
     *                              C = JΔ * α                                *
     * ---------------------------------------------------------------------- *
     * C  = Couple (N.m)                                                      *
     * JΔ = moment d'inertie (kg.m²)                                          *
     * α  = Accélération angulaire (rad/s²)                                   *
     * ---------------------------------------------------------------------- */

        couple = Jdelta * accAngulaire;

        // Ajout du point à la liste des points de la courbe du couple
        couplePoints.append(QPointF(rpm.at(i).toDouble(), couple));
        qDebug() << "couple (rpm, couple) = " << couplePoints.last();

    /* ---------------------------------------------------------------------- *
     *                        P = C * ((ω1 + ω2) / 2)                         *
     * ---------------------------------------------------------------------- *
     * P  = Puissance (Watts)                                                 *
     * ωx = Vitesse angulaire à l'instant x (rad/s)                           *
     * ---------------------------------------------------------------------- */

        wIntermediate = (w1 + w2) / 2;
        qDebug() << "(w1 + w2) / 2 = " << wIntermediate;

        puissance = couple * wIntermediate;

    /* ---------------------------------------------------------------------- *
     *               ωx = (π * Nx) / 30  <=> Nx = (30 * ωx) / π               *
     * ---------------------------------------------------------------------- *
     * ωx = Vitesse angulaire à l'instant x (rad/s)                           *
     * Π  = Pi, constante qui vaut 3.141592653589793...                       *
     * Nx = tours par minute à l'instant x == RPM (tours/minute)              *
     * ---------------------------------------------------------------------- */
        powerPoints.append(QPointF((30 * wIntermediate) / PI, puissance));
        qDebug() << "puissance (rpm, puissance) = " << powerPoints.last();

        lastDataIndice = i;
    }

    // Création de la courbe du couple
    QwtPointSeriesData* coupleSerieData = new QwtPointSeriesData(couplePoints);
    PlotCurve* coupleCurve = new PlotCurve(tr("Couple"), QPen(Qt::darkRed)); // TODO : ajouter le nom de l'essai (par défaut, le nom du dossier)
    coupleCurve->setData(coupleSerieData);
    coupleCurve->attach(this->couplePowerPlot);
    this->setPlotCurveVisibile(coupleCurve, true);

    // Création de la courbe de la puissance
    QwtPointSeriesData* powerSerieData = new QwtPointSeriesData(powerPoints);
    PlotCurve* powerCurve = new PlotCurve(tr("Puissance"), QPen(Qt::darkBlue)); // TODO : ajouter le nom de l'essai (par défaut, le nom du dossier)
    powerCurve->setData(powerSerieData);
    powerCurve->setAxes(Plot::xBottom, Plot::yRight);
    powerCurve->attach(this->couplePowerPlot);
    this->setPlotCurveVisibile(powerCurve, true);

    qDebug() << "Fin de la création des courbes ...";
}

/* -------------------------------------------------------------------------- *
 * Ancienne méthode utilisée pour créer une courbe de tendance d'ordre n      *
 * mais utilisait le version C de la fonction polynomialfit --> j'ai          *
 * créé une version C++ - Qt de cette meme fonction                           *
 * -------------------------------------------------------------------------- */
void MainWindow::createPolynomialTrendline(void)
{
    // if no curve associated to the legend item. This shouldn't happen!
    if (this->curveAssociatedToLegendItem == NULL)
        return;

    bool ok(false);
    int degree = QInputDialog::getInt(
                this, tr("Courbe de tendance polynomiale"),
                tr("Ordre de complexité ?"), 2, 2, 100, 1, &ok);

    if (!ok) // User canceled
        return;

    // Récupération de la liste des points de la courbe
    QwtSeriesData<QPointF>* serie = this->curveAssociatedToLegendItem->data();
    if (!serie)
        return;

    int size(serie->size());
    double x[size];
    double y[size];
    double coefficient[degree];

    // Récupération des coordonnées
    for(int i(0); i < size; ++i)
    {
        x[i] = serie->sample(i).x();
        y[i] = serie->sample(i).y();
    }

    // Recherche de tous les coefficients de l'équation
    polynomialfit(size, degree, x, y, coefficient);

    // Creation de la liste des points de la courbe
    QVector<QPointF> trendlinePoints;
    for(int i(0); i < size; ++i)
    {
        // Calcule les nouvelles valeurs de y
        double y(0);
        for(int j(0); j < degree; ++j)
            y += coefficient[j] * qPow(x[i], j);

        trendlinePoints.append(QPointF(x[i], y));
    }

    // Création de la courbe
    QwtPointSeriesData* trendlineSeriesData = new QwtPointSeriesData(trendlinePoints);
    PlotCurve* trendlineCurve = new PlotCurve(
                this->curveAssociatedToLegendItem->title().text() +
                tr(" Poly(") + QString::number(degree) + ")", QPen("lightskyblue"));
    trendlineCurve->setAxes(this->curveAssociatedToLegendItem->xAxis(),
                            this->curveAssociatedToLegendItem->yAxis());
    trendlineCurve->setData(trendlineSeriesData);
    trendlineCurve->attach(this->curveAssociatedToLegendItem->plot());
    this->setPlotCurveVisibile(trendlineCurve, true);
}

/* -------------------------------------------------------------------------- *
 *        Calcul de l'approximation polynomiale d'ordre 3 manuellement        *
 * -------------------------------------------------------------------------- */
void MainWindow::leastSqrRegression(
        const QVector<QPointF> &points, QString const& baseName,
        QwtPlot::Axis xAxis, QwtPlot::Axis yAxis)
{
   if (points.count() == 0)
   {
       qDebug() << "Aucune données à traiter";
       return;
   }

   // double  = 8  octets = 64  bits
   // decimal = 16 octets = 128 bits

   double SUMx4(0);  // sum of x^4
   double SUMx3(0);  // sum of x³
   double SUMx2(0);  // sum of x²
   double SUMx(0);   // sum of x
   double SUMx2y(0); // sum of x²*y
   double SUMxy(0);  // sum of x*y
   double SUMy(0);   // sum of y

   double a(0);
   double b(0);
   double c(0);

   // y = ax² + bx + c

   foreach (QPointF point, points)
   {
//       if (point.y() < 0.0)
//           continue;
       SUMx4  += qPow(point.x(), 4);
       SUMx3  += qPow(point.x(), 3);
       SUMx2  += qPow(point.x(), 2);
       SUMx   += point.x();
       SUMx2y += qPow(point.x(), 2) * point.y();
       SUMxy  += point.x() * point.y();
       SUMy   += point.y();
   }

   qDebug() << "x4 = " << SUMx4;
   qDebug() << "x3 = " << SUMx3;
   qDebug() << "x2 = " << SUMx2;
   qDebug() << "x = " << SUMx;
   qDebug() << "x²*y = " << SUMx2y;
   qDebug() << "x*y = " << SUMxy;
   qDebug() << "y = " << SUMy;

   a = ((points.count()*SUMx2y-SUMx2*SUMy)*(points.count()*SUMx2-qPow(SUMx, 2))
        -(points.count()*SUMxy-SUMx*SUMy) *(points.count()*SUMx3-SUMx2*SUMx))
                                          /
    ((points.count()*SUMx4-qPow(SUMx2, 2))*(points.count()*SUMx2-qPow(SUMx, 2))
     -qPow(SUMx2*SUMx-points.count()*SUMx3, 2));
   qDebug() << "a = " << a;

   b = (a*(SUMx2*SUMx-points.count()*SUMx3)+points.count()*SUMxy-SUMx*SUMy)
           / (points.count()*SUMx2-qPow(SUMx, 2));
   qDebug() << "b = " << b;

   c = (-a*SUMx2-b*SUMx+SUMy)/points.count();
   qDebug() << "c = " << c;

   QVector<QPointF> approxiPoints;
   foreach (QPointF point, points)
   {
       // y = a*x² + b*x + c
       approxiPoints.append(QPointF(point.x(), a*qPow(point.x(), 2) + b*point.x() + c));
   }

   // Création de la courbe
   QwtPointSeriesData* approxiSerieData = new QwtPointSeriesData(approxiPoints);
   PlotCurve* approxiCurve = new PlotCurve(tr("approxi ") + baseName, QPen(Qt::darkMagenta)); // TODO : ajouter le nom de l'essai (par défaut, le nom du dossier)
   approxiCurve->setAxes(xAxis, yAxis);
   approxiCurve->setData(approxiSerieData);
   approxiCurve->attach(this->couplePowerPlot);
   this->setPlotCurveVisibile(approxiCurve, true);
}
